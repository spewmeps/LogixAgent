# 无报错性能问题的 ftrace 识别方法论

> **核心认知**：性能问题 ≠ 异常事件发生，而是**"正常事件以不正常的方式出现"**

---

## 一、认知转变：从"找错"到"找偏态"

### 性能问题的三个特征

在纯性能问题场景下，ftrace 日志通常具有：

1. **没有 error / warning**
2. **每条事件看起来都"合法"**
3. **系统功能完全正确，只是慢 / 卡 / 抖**

### 核心方法不是"找错"，而是

> **找偏离正常分布的行为**

**示例对比**：

```
错误的思路：
"日志里没有错误，所以没问题" ❌

正确的思路：
"调度延迟从 2ms 变成 45ms，虽然都是合法的调度事件，
但分布明显偏态，这就是问题" ✅
```

---

## 二、三种入口视角

### 1️⃣ 时间视角（最重要）

**问自己三个问题**：

1. 某些阶段是否**比预期更长**？
2. 延迟是否**集中发生在特定窗口**？
3. 延迟是**偶发尖刺**还是**持续拖慢**？

**方法论要点**：

```
单次慢不一定是问题
慢的模式才是问题
```

**实践**：

```bash
# 对比正常和异常的延迟分布
scripts/performance_analyzer.py \
  --normal normal.txt \
  --abnormal problem.txt \
  --thread myapp
```

**判断标准**：

| 延迟模式 | 正常 | 可疑 | 严重 |
|---------|------|------|------|
| 平均延迟 | < 5ms | 5-20ms | > 20ms |
| 最大延迟 | < 10ms | 10-50ms | > 50ms |
| P99 延迟 | < 8ms | 8-30ms | > 30ms |
| 标准差 | 小 | 中等 | 大（抖动） |

---

### 2️⃣ 调度视角（性能问题的核心战场）

**在没有报错时，90% 的性能问题本质是**：

> **"该跑的没跑，跑的不是它"**

**你要识别的是**：

- 可运行但未运行的时间比例
- 实际运行者与"期望运行者"的偏差

**换句话说**：

```
性能问题 = 调度资源分配问题（不一定是 bug）
```

**实践分析**：

```bash
# 查看目标线程的 runnable 状态占比
scripts/sched_analyzer.py trace.txt --thread myapp

# 查看它 runnable 时 CPU 在干什么
scripts/timeline_analyzer.py trace.txt --target myapp --context 100ms
```

---

### 3️⃣ 干扰视角（被谁偷走了时间）

**不看目标线程做了什么，而是看**：

- 它**没运行时**，CPU 在干什么
- 谁在"合法地"占用时间

**关键转变**：

```
从："我的代码慢"
到："谁在合法打断我"
```

**典型干扰源**：

1. **高优先级实时线程**（最常见）
2. **中断/软中断密集**
3. **内核后台任务膨胀**（kworker, kswapd）
4. **其他应用争抢 CPU**

**识别命令**：

```bash
# 直接看时间窃贼
scripts/performance_analyzer.py \
  --normal normal.txt \
  --abnormal problem.txt \
  --thread myapp
```

---

## 三、五个性能异常信号

这些信号**不会报错，但一定会在 ftrace 中留下痕迹**。

### 信号 1：可运行 → 运行 延迟异常

**特征**：
```
[1234.567000] sched_wakeup: comm=myapp pid=1234  # runnable
[1234.612000] sched_switch: next_comm=myapp      # running
延迟：45ms ← 异常（正常应 < 5ms）
```

**含义**：

> CPU 忙，但忙的不是你

**这是最典型的无报错性能问题**

**诊断**：
```bash
scripts/sched_analyzer.py trace.txt --thread myapp --latency-threshold 10
```

---

### 信号 2：运行被频繁切碎

**特征**：
```
[1234.567000] sched_switch: next_comm=myapp
[1234.567800] sched_switch: prev_comm=myapp prev_state=R  # 0.8ms 后被抢占
[1234.568500] sched_switch: next_comm=myapp
[1234.569200] sched_switch: prev_comm=myapp prev_state=R  # 0.7ms 后又被抢占
```

**含义**：

> 线程"活着"，但几乎没干成事

**常见于**：
- 抢占严重
- 中断/软中断频繁
- 优先级配置不当

**诊断**：
```bash
# 查看平均运行时间片
scripts/sched_analyzer.py trace.txt --thread myapp
```

**判断标准**：
- 正常：平均时间片 > 5ms
- 切碎：平均时间片 < 1ms

---

### 信号 3：高频唤醒但低有效运行

**特征**：
```
大量 sched_wakeup 事件
但每次 running 时间很短
或很快又变成 sleeping
```

**含义**：

> 逻辑没错，但调度效率极低（空转）

**典型场景**：
- 轮询等待（应改为事件驱动）
- 忙等待锁
- 频繁的信号或定时器

**识别方法**：
```bash
# 统计 wakeup 频率
scripts/ftrace_parser.py trace.txt --filter-event sched_wakeup | \
  grep "comm=myapp" | wc -l

# 与运行时间对比
scripts/sched_analyzer.py trace.txt --thread myapp
```

**判断**：
- wakeup 频率 > 1000次/秒：异常
- wakeup 多但运行时间少：空转

---

### 信号 4：后台行为的时间膨胀

**特征**：

一些"看似无关"的内核活动，在异常场景下占比明显变大

**典型代表**：
- `kworker/*`：内核工作队列
- `kswapd`：内存回收
- `migration/*`：CPU 迁移
- `ksoftirqd/*`：软中断处理

**含义**：

> 不是你变慢，是"背景噪声"变吵了

**识别**：
```bash
# 对比事件分布
scripts/performance_analyzer.py \
  --normal normal.txt \
  --abnormal problem.txt \
  --thread myapp
```

**关注**：后台任务 CPU 占比从 5% → 78%

---

### 信号 5：对照场景的结构性差异（最重要）

**特征**：

正常与异常场景下，事件类型相同，但**分布完全不同**

**示例对比**：

| 指标 | 正常场景 | 异常场景 | 差异 |
|------|---------|---------|------|
| 平均延迟 | 2.1ms | 45.3ms | 21.6x |
| 调度切换 | 1200次/秒 | 850次/秒 | 少29% |
| 平均时间片 | 8.3ms | 2.1ms | 切碎75% |
| irq/28-GPU 占比 | 3.2% | 67.8% | +64.6% |

**含义**：

> 同样的代码路径，不同的执行效率

**这是性能问题的"指纹"**

---

## 四、七步 Checklist（可落地操作）

> **使用方式**：从上往下逐条过，任意一条出现"明显偏态"，就已经是问题线索

### ✅ 1. 时间分布是否异常（第一优先级）

**检查**：
- 是否存在**明显长于常态**的时间段？
- 延迟是单点偶发、连续成片、还是周期性出现？

**命令**：
```bash
scripts/performance_analyzer.py \
  --normal normal.txt \
  --abnormal problem.txt \
  --thread myapp
```

**看什么**：
- 平均延迟倍数（> 2x 异常）
- P95/P99 延迟增长
- 标准差变化（抖动）

**判断**：
> 只要"时间形态"变了，就值得继续

---

### ✅ 2. 目标线程是否"该跑却没跑"

**问三个固定问题**：

1. 它什么时候**具备运行条件**？（wakeup）
2. 它什么时候**真正开始运行**？（switch to）
3. 中间差了多久？

**判断标准不是"有没有延迟"，而是**：

> 这个延迟在正常场景是否存在

**命令**：
```bash
scripts/sched_analyzer.py trace.txt --thread myapp
```

---

### ✅ 3. CPU 时间归属是否合理

**当目标线程没运行时**：
- CPU 是否一直被占用？
- 占用者是否**稳定、持续**？

**关键判断**：

> 时间不是消失了，而是被别人合法拿走了

**命令**：
```bash
scripts/timeline_analyzer.py trace.txt --target myapp --context 100ms
```

**或使用性能分析器直接看时间窃贼**：
```bash
scripts/performance_analyzer.py \
  --normal normal.txt \
  --abnormal problem.txt \
  --thread myapp
```

---

### ✅ 4. 运行是否被"切碎"

**即使线程在运行，也要看**：
- 每次运行是否很短
- 是否频繁被打断

**这是典型的"看起来在跑，实际上没效率"**

**检查**：
```bash
scripts/sched_analyzer.py trace.txt --thread myapp
```

**看运行时间统计**：
- 平均时间片 < 1ms：严重切碎
- 抢占率 > 50%：频繁打断

---

### ✅ 5. 是否存在"无关行为膨胀"

**重点不是"有没有某类行为"，而是**：

> 在异常场景下，它是否占比明显上升

**典型配角**：
- 后台机制（kworker）
- 维护性内核行为（writeback）
- 系统服务型线程（ksoftirqd）

**方法论要点**：

> 性能问题常常是**配角戏份太多**

**识别**：
```bash
scripts/performance_analyzer.py \
  --normal normal.txt \
  --abnormal problem.txt \
  --thread myapp
```

**看事件激增部分**

---

### ✅ 6. 正常 vs 异常是否存在结构性差异

**这是定性 → 定责的关键一步**

**同样的行为**：
- 正常：分散、短暂
- 异常：集中、持续

**只要结构不同，就可以下结论**

**对比维度**：
1. **事件密度**：稀疏 vs 密集
2. **时间分布**：均匀 vs 突发
3. **占比变化**：正常范围 vs 异常膨胀

**实践**：

performance_analyzer.py 会自动给出结构性差异报告

---

### ✅ 7. 能否压缩成一条因果链

**最后强制自己完成这一步**：

```
在异常场景中，
A 的时间占比上升（量化）→
挤占了 B 的可运行时间（量化）→
导致整体性能下降（量化）
```

**示例**：

```
在异常场景中，
irq/28-GPU 的 CPU 时间从 3.2% 上升到 67.8%（+64.6%）→
挤占了 myapp 的运行时间，使其调度延迟从 2.1ms 增至 45.3ms（21.6x）→
导致应用吞吐量下降 58%
```

**如果做不到**：
- 说明日志还没被"抽象干净"
- 或分析顺序错了

---

## 五、典型错觉与纠正

### 错觉 1：没有异常日志 = 系统没问题

❌ **错**

✅ **性能问题几乎从不报错**

---

### 错觉 2：函数调用多 = 性能问题

❌ **错**

✅ **慢不等于多，慢等于被打断**

**正确思路**：
```
不看调用了多少次
看调用之间被打断多少次
```

---

### 错觉 3：一次慢就算问题

❌ **错**

✅ **要看分布和重现性**

**判断标准**：
- 偶发一次：可能不是问题
- P99 偏高：需要关注
- 持续偏高：肯定是问题

---

### 错觉 4：日志越详细越好

❌ **错**

✅ **只看异常时间窗口内的关键事件**

**方法论**：
```
不是收集所有信息
而是过滤出偏态信息
```

---

## 六、如何定位责任方（反证法）

### 不要试图证明"谁有问题"

而是：

1. **证明目标线程没有获得应有资源**
   - 量化：runnable 时间占比
   - 对比：正常场景的资源获得量

2. **证明资源被别人合法占用**
   - 识别：谁在占用 CPU
   - 量化：占用时间和占比

3. **排除其他可能的占用者**
   - 中断是否正常？
   - 其他应用是否异常？
   - 内核后台任务是否合理？

### ftrace 在这里的角色是

> **时间归属证明工具**

不是证明"谁错了"，而是证明"时间去哪了"

---

## 七、分析顺序（非常关键）

### ❌ 错误顺序

1. 看函数
2. 看调用
3. 看代码路径

### ✅ 正确顺序

1. **时间是否异常**
   - 对比正常场景
   - 量化延迟变化

2. **状态是否合理**
   - runnable 占比
   - running 占比
   - blocked 占比

3. **谁占用了时间**
   - CPU 时间归属
   - 干扰源识别

4. **为什么它可以占用**
   - 优先级机制
   - 调度策略
   - 资源竞争

---

## 八、结论标准格式

在无报错场景下，一个合格结论应是：

```
在异常场景中，X 的可运行未执行时间显著增加（从 2.1ms 增至 45.3ms），
期间 CPU 主要被 Y 占用（占比从 3.2% 增至 67.8%），
该行为在正常场景不存在或占比极低，
因此性能退化由 Y 的时间膨胀导致。
```

**注意**：

- **不需要任何 error 佐证**
- **全靠时间、比例、对照**
- **必须量化**

---

## 九、一句话总结

> **ftrace 不是用来发现"错误"的工具，而是用来发现"时间被谁拿走了"的工具。**

> **在没有报错的世界里，时间本身就是唯一的异常信号。**

---

## 十、快速判断标准

### 你能不能不用任何 error / warning，只用"时间 + 对照"，说服一个不懂内核的人？

**好的例子**：

```
"应用延迟从平均 2ms 变成 45ms，增加了 21 倍。
分析发现，原本只占 3% CPU 时间的 GPU 中断处理线程，
在问题场景中占用了 68% 的 CPU 时间，
导致应用无法及时获得 CPU 资源。"
```

**坏的例子**：

```
"调度有问题" ❌
"系统负载高" ❌
"可能是优先级问题" ❌
```

---

## 十一、实战流程图

```
问题出现（慢/卡/抖）
        ↓
抓取对照日志（正常 + 异常）
        ↓
使用 performance_analyzer.py 对比
        ↓
    ┌───┴───┐
    │ 有偏态？│
    └───┬───┘
        │ Yes
        ↓
识别五个异常信号
        ↓
    ┌───┴───┐
    │信号明显？│
    └───┬───┘
        │ Yes
        ↓
走七步 Checklist
        ↓
定位时间窃贼
        ↓
构建因果链
        ↓
量化结论
```

记住：**性能问题的本质是时间分配问题，不是功能错误问题**
