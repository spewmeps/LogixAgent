| 场景序号 | 场景描述 | 场景分析目的 | 对应 SQL |
| ---- | ---- | ------ | ------ |
| 1 | CPU利用率分布 | 识别CPU负载不均衡 | ```sql<br>SELECT<br>  cpu,<br>  sum(dur) / 1e9 AS cpu_time_seconds,<br>  100.0 * sum(dur) / (SELECT sum(dur) FROM sched) AS cpu_usage_percent<br>FROM sched<br>GROUP BY cpu<br>ORDER BY cpu_usage_percent DESC;<br>``` |
| 2 | 上下文切换频率 | 发现过度调度问题 | ```sql<br>SELECT<br>  cpu,<br>  count(*) AS ctx_switches,<br>  count(*) * 1e9 / (SELECT max(ts) - min(ts) FROM sched) AS switches_per_sec<br>FROM sched<br>GROUP BY cpu;<br>``` |
| 3 | 进程/线程运行时间片 | 识别抢占和饥饿 | ```sql<br>SELECT<br>  t.name,<br>  avg(s.dur) AS avg_slice_dur,<br>  max(s.dur) AS max_slice_dur,<br>  count(*) AS slice_count<br>FROM sched s<br>JOIN thread t USING (utid)<br>GROUP BY utid<br>ORDER BY avg_slice_dur ASC<br>LIMIT 20;<br>``` |
| 4 | 调度延迟(latency) | 评估实时性能 | ```sql<br>INCLUDE PERFETTO MODULE sched.latency;<br>SELECT<br>  t.name,<br>  avg(latency_dur) AS avg_latency,<br>  max(latency_dur) AS max_latency<br>FROM sched_latency_for_running_interval<br>JOIN thread t USING (utid)<br>GROUP BY utid<br>ORDER BY max_latency DESC<br>LIMIT 20;<br>``` |
| 5 | 硬中断频率和时长 | 发现中断风暴 | ```sql<br>INCLUDE PERFETTO MODULE linux.irqs;<br>SELECT<br>  name,<br>  count(*) AS count,<br>  sum(dur) AS total_dur,<br>  avg(dur) AS avg_dur<br>FROM linux_hard_irqs<br>GROUP BY name<br>ORDER BY count DESC;<br>``` |
| 6 | 软中断(softirq)耗时 | 识别网络/IO瓶颈 | ```sql<br>INCLUDE PERFETTO MODULE linux.irqs;<br>SELECT<br>  name,<br>  sum(dur) AS total_dur,<br>  avg(dur) AS avg_dur<br>FROM linux_soft_irqs<br>GROUP BY name<br>ORDER BY total_dur DESC;<br>``` |
| 7 | 运行态(Running)时长 | 识别CPU密集型任务 | ```sql<br>SELECT<br>  t.name,<br>  p.name AS process_name,<br>  sum(dur) AS total_running_dur<br>FROM sched s<br>JOIN thread t USING (utid)<br>LEFT JOIN process p USING (upid)<br>GROUP BY utid<br>ORDER BY total_running_dur DESC<br>LIMIT 10;<br>``` |
| 8 | 睡眠态(Sleep)时长 | 发现IO等待 | ```sql<br>SELECT<br>  t.name,<br>  sum(dur) AS sleep_dur<br>FROM thread_state ts<br>JOIN thread t USING (utid)<br>WHERE state = 'S'<br>GROUP BY utid<br>ORDER BY sleep_dur DESC<br>LIMIT 10;<br>``` |
| 9 | 不可中断睡眠(D状态) | 发现IO等待/锁等待 | ```sql<br>SELECT<br>  t.name,<br>  sum(dur) AS d_state_dur<br>FROM thread_state ts<br>JOIN thread t USING (utid)<br>WHERE state = 'D'<br>GROUP BY utid<br>ORDER BY d_state_dur DESC<br>LIMIT 10;<br>``` |
| 10 | 锁等待时间 | 识别同步瓶颈 | ```sql<br>-- 假设有锁相关的slice事件<br>SELECT<br>  name,<br>  sum(dur) AS total_wait_dur,<br>  count(*) AS wait_count<br>FROM slice<br>WHERE name GLOB '*lock*' OR name GLOB '*contention*'<br>GROUP BY name<br>ORDER BY total_wait_dur DESC;<br>``` |
| 11 | 缺页中断频率 | 内存压力评估 | ```sql<br>SELECT<br>  t.name,<br>  sum(c.value) AS total_faults<br>FROM counter c<br>JOIN counter_track t ON c.track_id = t.id<br>WHERE t.name LIKE '%page_fault%'<br>GROUP BY t.name;<br>``` |
| 12 | 块设备IO延迟 | 存储性能 | ```sql<br>-- 统计Block IO类型slice的平均耗时<br>SELECT<br>  name,<br>  avg(dur) AS avg_latency,<br>  max(dur) AS max_latency<br>FROM slice<br>WHERE category = 'block_io'<br>GROUP BY name<br>ORDER BY avg_latency DESC;<br>``` |
| 13 | syscall耗时分布 | 发现慢系统调用 | ```sql<br>SELECT<br>  name,<br>  avg(dur) AS avg_dur,<br>  max(dur) AS max_dur,<br>  count(*) AS call_count<br>FROM slice<br>WHERE category = 'syscall'<br>GROUP BY name<br>ORDER BY avg_dur DESC<br>LIMIT 20;<br>``` |
| 14 | 热点函数耗时 | 性能瓶颈 | ```sql<br>INCLUDE PERFETTO MODULE slices.flat_slices;<br>SELECT<br>  name,<br>  sum(dur) AS self_time<br>FROM _slice_flattened<br>GROUP BY name<br>ORDER BY self_time DESC<br>LIMIT 20;<br>``` |
| 15 | 中断分布不均 | CPU亲和性问题 | ```sql<br>SELECT<br>  t.name AS track_name,<br>  count(*) AS irq_count<br>FROM slice s<br>JOIN track t ON s.track_id = t.id<br>WHERE t.type = 'cpu_irq'<br>GROUP BY t.name<br>ORDER BY irq_count DESC;<br>``` |
| 16 | 僵尸进程/异常退出 | 系统稳定性 | ```sql<br>SELECT<br>  t.name,<br>  count(*) AS zombie_count<br>FROM thread_state ts<br>JOIN thread t USING (utid)<br>WHERE state = 'Z' OR state = 'X'<br>GROUP BY t.name<br>ORDER BY zombie_count DESC;<br>``` |
| 17 | 内存回收(reclaim)活动 | 内存不足 | ```sql<br>SELECT<br>  name,<br>  sum(dur) AS total_dur,<br>  count(*) AS count<br>FROM slice<br>WHERE name GLOB '*kswapd*' OR name GLOB '*reclaim*'<br>GROUP BY name<br>ORDER BY total_dur DESC;<br>``` |
| 18 | IO操作频率 | 识别IO热点 | ```sql<br>SELECT<br>  name,<br>  count(*) AS io_count<br>FROM slice<br>WHERE category = 'block_io'<br>GROUP BY name<br>ORDER BY io_count DESC;<br>``` |
| 19 | QoS限流/调度延迟规律分析 | 识别Cgroup/QoS限流导致的规律性延迟 | ```sql<br>INCLUDE PERFETTO MODULE sched.latency;<br>SELECT<br>  t.name AS thread_name,<br>  count(*) AS latency_count_total,<br>  SUM(CASE WHEN latency_dur BETWEEN 5000000 AND 10000000 THEN 1 ELSE 0 END) AS count_5ms_10ms,<br>  SUM(CASE WHEN latency_dur > 10000000 THEN 1 ELSE 0 END) AS count_over_10ms,<br>  MAX(latency_dur) AS max_latency,<br>  AVG(latency_dur) AS avg_latency<br>FROM sched_latency_for_running_interval<br>JOIN thread t USING (utid)<br>WHERE latency_dur > 5000000<br>GROUP BY t.name<br>ORDER BY count_5ms_10ms DESC<br>LIMIT 20;<br>``` |
| 20 | 唤醒源统计 | 分析唤醒关系，定位谁在唤醒关键线程 | ```sql<br>SELECT<br>  waker.name AS waker_thread,<br>  wakee.name AS wakee_thread,<br>  count(*) AS wake_count<br>FROM thread_state ts<br>JOIN thread waker ON ts.waker_utid = waker.utid<br>JOIN thread wakee ON ts.utid = wakee.utid<br>WHERE ts.state = 'R'<br>GROUP BY waker.name, wakee.name<br>ORDER BY wake_count DESC<br>LIMIT 20;<br>``` |
| 21 | Futex/锁竞争 | 识别用户态锁竞争(通过syscall) | ```sql<br>SELECT<br>  name,<br>  count(*) AS count,<br>  avg(dur) AS avg_dur<br>FROM slice<br>WHERE name LIKE 'sys_futex%'<br>GROUP BY name<br>ORDER BY count DESC;<br>``` |
| 22 | 长时D状态(疑似死锁) | 发现超过5秒的不可中断睡眠 | ```sql<br>SELECT<br>  t.name,<br>  ts.state,<br>  ts.dur,<br>  ts.ts<br>FROM thread_state ts<br>JOIN thread t USING (utid)<br>WHERE ts.state = 'D' AND ts.dur > 5000000000<br>ORDER BY ts.dur DESC<br>LIMIT 20;<br>``` |
| 23 | 内存分配耗时 | 评估内核内存分配延迟 | ```sql<br>SELECT<br>  name,<br>  count(*) AS count,<br>  avg(dur) AS avg_dur,<br>  max(dur) AS max_dur<br>FROM slice<br>WHERE name GLOB '*alloc*'<br>  AND (category GLOB '*kmem*' OR category GLOB '*mm*')<br>GROUP BY name<br>ORDER BY avg_dur DESC;<br>``` |
| 24 | Trace时间范围概览 | 确认Trace时长和基本规模 | ```sql<br>SELECT<br>  (max(ts) - min(ts)) / 1e9 AS duration_sec,<br>  count(*) AS sched_events<br>FROM sched;<br>``` |
| 25 | Slice事件分类统计 | 了解系统活动分布 | ```sql<br>SELECT<br>  category,<br>  count(*) AS count<br>FROM slice<br>GROUP BY category<br>ORDER BY count DESC;<br>``` |
| 26 | 调用栈深度分析 | 评估函数调用复杂度(需相关Trace) | ```sql<br>SELECT<br>  depth,<br>  count(*) AS count<br>FROM slice<br>GROUP BY depth<br>ORDER BY depth DESC;<br>``` |
| 27 | Top耗时事件(单次) | 发现极端的长耗时操作 | ```sql<br>SELECT<br>  name,<br>  dur,<br>  ts<br>FROM slice<br>ORDER BY dur DESC<br>LIMIT 20;<br>``` |
| 28 | 进程级CPU消耗排名 | 宏观评估各进程负载 | ```sql<br>SELECT<br>  p.name AS process_name,<br>  sum(s.dur) / 1e9 AS cpu_time_sec<br>FROM sched s<br>JOIN thread t USING (utid)<br>LEFT JOIN process p USING (upid)<br>GROUP BY p.name<br>ORDER BY cpu_time_sec DESC<br>LIMIT 20;<br>``` |
| 29 | 活跃线程统计 | 评估系统并发规模 | ```sql<br>SELECT<br>  count(distinct utid) AS active_threads_count<br>FROM sched;<br>``` |
| 30 | 调度时间轴不连续检测 | 发现Trace数据丢失或溢出 | ```sql<br>SELECT<br>  ts,<br>  ts - lag(ts) OVER (ORDER BY ts) AS gap<br>FROM sched<br>ORDER BY gap DESC<br>LIMIT 10;<br>``` |
